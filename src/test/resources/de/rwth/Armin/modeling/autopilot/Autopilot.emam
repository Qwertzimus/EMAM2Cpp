package de.rwth.armin.modeling.autopilot;

import de.rwth.armin.modeling.autopilot.basicComp.*;
import fas.basicLibrary.*;

component Autopilot {
  port
    in Q (0.0 s : 0.001 s : 1.0 s) timeIncrement,
    in Q (0.0 m/s : 0.01 m/s : oo m/s) currentVelocity,
    in Q currentGpsLat,
    in Q currentGpsLon,
    in Q compass,
    in Q (0.0 : 0.001 : 2.5) currentEngine,
    in Q (-0.775 : 0.001 : 0.775) currentSteering,
    in Q (0.0 : 0.001 : 3.0) currentBrakes,
    in Z (-1 : 9999) goalNodeId,
    in Z (0 : 10000) addNodes_length,
    in Z (0 : 9999) ^ {1,10000} addNodes_id,
    in Q ^ {1,10000} addNodes_gpsLat, // Von allen knoten
    in Q ^ {1,10000} addNodes_gpsLon,
    in Z (0 : 10000) removeNodes_length,
    in Z (0 : 9999) ^ {1,10000} removeNodes_id,   // begrenzung wegen buffer overflow
    in Z (0 : 10000) addOrUpdateEdges_length,
    in Z (0 : 9999) ^ {1,10000} addOrUpdateEdges_fromNodeId,
    in Z (0 : 9999) ^ {1,10000} addOrUpdateEdges_toNodeId,
    in Q (0 : oo) ^ {1,10000} addOrUpdateEdges_cost,
    in Z (0 : 10000) removeEdges_length,
    in Z (0 : 9999) ^ {1,10000} removeEdges_fromNodeId,
    in Z (0 : 9999) ^ {1,10000} removeEdges_toNodeId,

    out Q (0.0 : 0.001 : 2.5) engine,
    out Q (-0.775 : 0.001 : 0.775) steering,
    out Q (0.0 : 0.001 : 3.0) brakes;

    instance PID veloPid;

    // causes stream tests to be generated
    instance Tests;

    connect 5 -> veloPid.desiredVel;
    connect currentVelocity -> veloPid.currentVel;

    connect  veloPid.engineVal -> engine;
    connect  veloPid.breakesVal -> brakes;
    connect  timeIncrement -> veloPid.timeInc;

    connect 0.0 -> steering;

// alle 5ms aufgerufen
  //implementation Math {
  //  if addNodes_length > 0 {
  //    Q sumLat = 0.0;
  //    for i = 1 : addNodes_length for
  //      sumLat = sumLat + addNodes_gpsLat(1,i);
  //    end
  //    engine = 1.0 / abs(sumLat);
  //  } else {
  //    engine = 2.5;
  //  } end
  //  steering = 0.0;
  //  brakes = 0.0;
  //}
}
