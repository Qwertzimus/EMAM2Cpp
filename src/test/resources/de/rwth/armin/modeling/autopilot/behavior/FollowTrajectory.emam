package de.rwth.armin.modeling.autopilot.behavior;

component FollowTrajectory {
  port
    in  B                                        isDriveToFirstPosition,
    in  Q (-oo m : 0.01 m : oo m)                currentPositionX,
    in  Q (-oo m : 0.01 m : oo m)                currentPositionY,
    in  Z (0 : 100)                              trimmedTrajectoryLength,
    in  Q (-oo m : 0.01 m : oo m) ^ {1,100}      trimmedTrajectoryX,
    in  Q (-oo m : 0.01 m : oo m) ^ {1,100}      trimmedTrajectoryY,

    out Q (-oo m : 0.01 m : oo m)                desiredDirectionX,
    out Q (-oo m : 0.01 m : oo m)                desiredDirectionY,
    out Q (-oo m : 0.01 m : oo m)                signedDistanceToTrajectory,
    out Q (0.0 m/s : 0.01 m/s : 13.0 m/s)        minVelocity,
    out Q (0.0 m/s : 0.01 m/s : 13.0 m/s)        maxVelocity,
    out Q (0.0 m/s : 0.01 m/s : 13.0 m/s)        distance;

  implementation Math {
    // change to params later
    static Q NUMBER_OF_INTERMEDIATE_INTERPOLATION_POINTS = 10.0;
    static Q TURN_ANGLE_THRESHOLD = 10.0 * M_PI / 180.0; // 10 degrees
    static Q EPSILON = 0.000001;
    desiredDirectionX = 0.0;
    desiredDirectionY = 0.0;
    signedDistanceToTrajectory = 0.0;
    minVelocity = 0.0;
    maxVelocity = 0.0;
    distance = 0.0;
    if (isDriveToFirstPosition)
      Q doNothing;
    elseif (trimmedTrajectoryLength >= 2)
      maxVelocity = 13.0;
      // SIGNED DISTANCE
      Q p1x = trimmedTrajectoryX(1,1);
      Q p1y = trimmedTrajectoryY(1,1);
      Q p2x = trimmedTrajectoryX(1,2);
      Q p2y = trimmedTrajectoryY(1,2);
      Q v12x = p2x - p1x;
      Q v12y = p2y - p1y;
      Q v12_sqr_norm = v12x*v12x + v12y*v12y;
      if (v12_sqr_norm > EPSILON)
        // https://en.wikipedia.org/wiki/Distance_from_a_point_to_a_line#Line_defined_by_two_points
        Q v12_norm = sqrt(v12_sqr_norm);
        signedDistanceToTrajectory = -(v12y*currentPositionX - v12x*currentPositionY + p2x*p1y - p1x*p2y) / v12_norm;
      end
      // DESIRED DIRECTION
      Q interp_p1x = currentPositionX;
      Q interp_p1y = currentPositionY;
      Q interp_p2x = p1x;
      Q interp_p2y = p1y;
      Q interp_p3x = p2x;
      Q interp_p3y = p2y;
      if (trimmedTrajectoryLength >= 3)
        Q interp_p2x = p2x;
        Q interp_p2y = p2y;
        Q interp_p3x = trimmedTrajectoryX(1,3);
        Q interp_p3y = trimmedTrajectoryY(1,3);
      end
      // Bezier interpolation
      Q t = 1.0 / (NUMBER_OF_INTERMEDIATE_INTERPOLATION_POINTS + 1.0);
      Q a = 1.0 - t;
      Q b = t;
      Q k1 = a * a;
      Q k2 = 2 * a * b;
      Q k3 = b * b;
      Q nextX = k1 * interp_p1x + k2 * interp_p2x + k3 * interp_p3x;
      Q nextY = k1 * interp_p1y + k2 * interp_p2y + k3 * interp_p3y;
      desiredDirectionX = nextX - currentPositionX;
      desiredDirectionY = nextY - currentPositionY;
      // DISTANCE
      Q dist = sqrt( (p2x-p1x)*(p2x-p1x) + (p2y-p1y)*(p2y-p1y) );
      if (trimmedTrajectoryLength >= 3)
        minVelocity = 1.0;
        Q is_go_on = 1;
        Q lastIndex = trimmedTrajectoryLength - 2;
        for i = 1:lastIndex
          if (is_go_on)
            Q pt1x = trimmedTrajectoryX(1,i);
            Q pt1y = trimmedTrajectoryY(1,i);
            Q pt2x = trimmedTrajectoryX(1,i+1);
            Q pt2y = trimmedTrajectoryY(1,i+1);
            Q pt3x = trimmedTrajectoryX(1,i+2);
            Q pt3y = trimmedTrajectoryY(1,i+2);
            Q vect1x = pt2x - pt1x;
            Q vect1y = pt2y - pt1y;
            Q vect2x = pt3x - pt2x;
            Q vect2y = pt3y - pt2y;
            Q vect1_norm = sqrt( vect1x*vect1x + vect1y*vect1y );
            Q vect2_norm = sqrt( vect2x*vect2x + vect2y*vect2y );
            Q cos_alpha = (vect1x*vect2x + vect1y*vect2y) / vect1_norm / vect2_norm;
            Q alpha = acos(cos_alpha);
            if (alpha > TURN_ANGLE_THRESHOLD)
              is_go_on = 0;
            else
              dist += vect2_norm;
            end
          end
        end
      end
      distance = dist;
    end
  }
}
